<?xml version="1.0" encoding="iso-8859-1"?>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<title>perlintro</title>
		<meta charset="utf-8"/>
	</head>
	<body class="pod">
		<span id="___top"/>
		<h1><span id="NAME">NAME</span></h1>
		<p>perlintro -- Perl简介和概览</p>
		<h1><span id="DESCRIPTION">DESCRIPTION</span></h1>
		<p>&#35813;文档将为您提供Perl编程语言的快速概览，并指导您阅读其他更深入的文档。 对于刚刚接触Perl的人，它可以被当作一份"入门"向导。它提供刚刚好的信息， 使你能够阅读别人的Perl代码并粗略知道这些代码在做什么，以及能够自己编写简单 的脚本。</p>
		<p>&#36825;份介绍性的文档并不打算覆盖全面。它甚至不打算写的非常精确。有时为了抓住重点， 我们必须牺牲完美。<i>&#24378;烈</i>&#24314;议您看完本介绍以后继续阅读整个Perl手册获取更多的信息。 Perl手册的目录参见<a href="perltoc.html" class="podlinkpod">perltoc</a>&#12290;</p>
		<p>&#22312;本文档中你会到处看到对Perl文档的其他部分的引用。你可以使用你现在正用来阅读 本文档的方法或<code>perldoc</code>&#25351;令去阅读那些文档。</p>
		<h2><span id="Perl(26159)(20160)(20040)(65311)">Perl是什么？</span></h2>
		<p>Perl是一门常规用途的语言。最初被开发出来用于文本处理（维护）。现在被用于系统 管理、web开发、网络编程、图形用户界面(GUI)开发以及更多其他等各种任务。</p>
		<p>&#36825;门语言被设计得实用(容易使用、高效、完整)胜于美观(微小、文雅、简化)。它的 主要特点是容易使用，支持面向过程编程和面向对象编程，内建强大的文本处理能力， 以及拥有世界上最著名的第三方模块集合。</p>
		<p><a href="perl.html" class="podlinkpod">perl</a>&#65292;<a href="perlfaq1.html" class="podlinkpod">perlfaq1</a>&#21644;其他地方给出了关于Perl的不同定义。从而我们可以看出Perl 对于不同的人意味着不同的东西，但至少他们都愿意把它记述下来。</p>
		<h2><span id="(36816)(34892)Perl(31243)(24207)">&#36816;行Perl程序</span></h2>
		<p>&#20174;Unix命令行运行Perl程序：</p>
		<pre>    perl progname.pl</pre>
		<p>&#25110;者把下面的代码写到你脚本的第一行：</p>
		<pre>    #!/usr/bin/env perl</pre>
		<p>... 然后运行<code>/path/to/script.pl</code>&#12290;当然，该脚本必须具有执行权限，使用 <code>chmod 755 script.pl</code>&#25913;变权限(Unix下)。</p>
		<p>&#26356;多信息，包括其他平台(如Windows和Mac OS)的说明，请阅读<a href="perlrun.html" class="podlinkpod">perlrun</a>&#12290;</p>
		<h2><span id="(22522)(26412)(35821)(27861)(27010)(35272)">&#22522;本语法概览</span></h2>
		<p>&#19968;个Perl脚本/程序由一条或多条语句组成。这些语句直接写在脚本里，而不是需要写 在什么<code>main()</code>&#25110;者类似的东西里。</p>
		<p>perl语句以分号(;)结尾：</p>
		<pre>    print "Hello, world";</pre>
		<p>&#27880;释使用井号(#)开始，作用直到该行末尾</p>
		<pre>    # 这是一个注释</pre>
		<p>&#31354;白是无关紧要的：</p>
		<pre>    print 
        "Hello, world"
        ;</pre>
		<p>... 除非是在被引起来的字符串里：</p>
		<pre>    # 下面的打印中间会有一个换行符
    print "Hello
    world";</pre>
		<p>&#21487;以使用双引号或单引号包围文字串：</p>
		<pre>    print "Hello, world";
    print 'Hello, world';</pre>
		<p>&#28982;而，只有双引号可以"内插"变量和特殊字符，如换行(<code>\n</code>)：</p>
		<pre>    print "Hello, $name\n";     # 内插变量和换行
    print 'Hello, $name\n';     # 打印出字面的$name\n</pre>
		<p>&#25968;字不需要用引号引起：</p>
		<pre>    print 42;</pre>
		<p>&#20320;可以根据你的喜好选择把函数参数用括号括起来，或者忽略括号。括号只有在偶尔用于 阐明优先级问题的时候才被需要。</p>
		<pre>    print("Hello, world\n");
    print "Hello, world\n";</pre>
		<p>&#20851;于Perl语法的详细信息请参阅<a href="perlsyn.html" class="podlinkpod">perlsyn</a>&#12290;</p>
		<h2><span id="Perl(21464)(37327)(31867)(22411)">Perl变量类型</span></h2>
		<p>Perl有三种变量类型：标量(scalar)、数组(array)、散列(hash)。</p>
		<dl>
			<dt><span id="(26631)(37327)(scalar)">&#26631;量(scalar)</span></dt>
			<dd>
				<p>&#19968;个标量表示一个单一的值：</p>
				<pre>    my $animal = "camel";
    my $answer = 42;</pre>
				<p>&#26631;量可以是字符串、整数或浮点数。在需要的时候，Perl可以自动对它们进行相互转换。 不需要预先声明变量类型。</p>
				<p>&#26631;量的使用可以有几种方式：</p>
				<pre>    print $animal;
    print "The animal is $animal\n";
    print "The square of $answer is ", $answer * $answer, "\n";</pre>
				<p>&#26377;许多看起来像标点符号或行噪音(line noise)的"魔力"标量。这些特殊的标量被用于 各种用途，参考<a href="perlvar.html" class="podlinkpod">perlvar</a>&#12290;现在你唯一需要知道的是<code>$_</code>&#65292;即"缺省变量"。它被用 作Perl中许多函数的缺省参数，另外某些循环结构会隐含地设置它的值。</p>
				<pre>    print;          # 缺省会打印出$_的内容</pre>
			</dd>
			<dt><span id="(25968)(32452)">&#25968;组</span></dt>
			<dd>
				<p>&#19968;个数组表示一系列值(一些值的列表)：</p>
				<pre>    my @animals = ("camel", "llama", "owl");
    my @numbers = (23, 42, 69);
    my @mixed   = ("camel", 42, 1.23);</pre>
				<p>&#25968;组下标从0开始。下面展示了如何从数组中获取元素：</p>
				<pre>    print $animals[0];              # prints "camel"
    print $animals[1];              # prints "llama"</pre>
				<p>&#29305;殊变量<code>$#array</code>&#33021;告诉你一个数组的最后一个元素的下标：</p>
				<pre>    print $mixed[$#mixed];       # 最后一个元素，输出1.23</pre>
				<p>&#20320;可能会被引诱使用<code>$#array + 1</code>&#26469;获取数组中元素的个数。别烦恼。再有这种需要 的时候，在Perl期待标量值的地方("在标量上下文中")使用<code>@array</code>&#23601;能得到数组中元 素的个数：</p>
				<pre>    if (@animals &lt; 5) { ... }</pre>
				<p>&#25105;们从数组中获取元素是以<code>$</code>&#25171;头，这是因为我们从数组中取出的仅仅是一个单一的 值 -- 你请求一个标量，你得到一个标量。</p>
				<p>&#35201;从数组中取得多个值：</p>
				<pre>    @animals[0,1];                  # 得到 ("camel", "llama");
    @animals[0..2];                 # 得到 ("camel", "llama", "owl");
    @animals[1..$#animals];         # 得到除第一个之外的所有元素</pre>
				<p>&#36825;叫做"数组切片"。</p>
				<p>&#20320;可以对列表做各种有用的事：</p>
				<pre>    my @sorted    = sort @animals;
    my @backwards = reverse @numbers;</pre>
				<p>&#21516;样，也存在也些特殊的数组，比如<code>@ARGV</code>(脚本的命令行参数)和<code>@_</code>(传递给子例程 的参数)。这些都在<a href="perlvar.html" class="podlinkpod">perlvar</a>&#20013;有详细文档。</p>
			</dd>
			<dt><span id="(25955)(21015)">&#25955;列</span></dt>
			<dd>
				<p>&#19968;个散列表示一套"键/值"对：</p>
				<pre>    my %fruit_color = ("apple", "red", "banana", "yellow");</pre>
				<p>&#20320;可以用空白和<code>=&gt;</code>&#25805;作符把它们摆放的漂亮些：</p>
				<pre>    my %fruit_color = (
        apple  =&gt; "red",
        banana =&gt; "yellow",
    );</pre>
				<p>&#35201;获取一个散列元素：</p>
				<pre>    $fruit_color{"apple"};           # 得到 "red"</pre>
				<p>&#20320;可以分别使用<code>keys()</code>&#21644;<code>values()</code>&#33719;取散列的键列表和值列表。</p>
				<pre>    my @fruits = keys %fruit_colors;
    my @colors = values %fruit_colors;</pre>
				<p>&#25955;列没有特定的内部顺序，尽管你可以排列所有的键并遍历它们。</p>
				<p>&#23601;像特殊标量和特殊数组，Perl里也有特殊散列。这其中最著名的是<code>%ENV</code>&#12290;它包含着 所有环境变量。关于这个(和其他特殊变量)请阅读<a href="perlvar.html" class="podlinkpod">perlvar</a>&#12290;</p>
			</dd>
		</dl>
		<p>&#21464;量、数组和散列的更多文档请见<a href="perldata.html" class="podlinkpod">perldata</a>&#12290;</p>
		<p>&#26356;复杂的数据类型使用引用构造，可以使你创建列表和散列的列表和散列。</p>
		<p>&#19968;个引用是一个标量值。它可以指向(引用)任何其他数据类型(的值)。这样，通过存储 一个对数组或散列的引用，你可以轻易地创建列表和散列的列表和散列。</p>
		<pre>    my $variables = {
        scalar  =&gt;  { 
                     description =&gt; "single item",
                     sigil =&gt; '$',
                    },
        array   =&gt;  {
                     description =&gt; "ordered list of items",
                     sigil =&gt; '@',
                    },
        hash    =&gt;  {
                     description =&gt; "key/value pairs",
                     sigil =&gt; '%',
                    },
    };

    print "Scalars begin with a $variables-&gt;{'scalar'}-&gt;{'sigil'}\n";</pre>
		<p>&#20851;于引用这个主题的详细信息可以参见<a href="perlreftut.html" class="podlinkpod">perlreftut</a>&#12289;<a href="perllol.html" class="podlinkpod">perllol</a>&#12289;<a href="perlref.html" class="podlinkpod">perlref</a>&#21644; <a href="perldsc.html" class="podlinkpod">perldsc</a>&#12290;</p>
		<h2><span id="(21464)(37327)(20316)(29992)(22495)">&#21464;量作用域</span></h2>
		<p>&#36143;穿之前章节的所有例子，都使用了这样的语法：</p>
		<pre>    my $var = "value";</pre>
		<p><code>my</code>&#23454;际上不是必须的；你可以仅仅使用这样的语法：</p>
		<pre>    $var = "value";</pre>
		<p>&#28982;后，上面这种用法会创建贯穿你程序的全局变量。这是一个不好的编程习惯。而<code>my</code> 创建的是词法变量。这种变量的作用域会局限于定义它的块(也就是一套包围在大括 号({})里的语句)里。</p>
		<pre>    my $a = "foo";
    if ($some_condition) {
        my $b = "bar";
        print $a;           # 输出 "foo"
        print $b;           # 输出 "bar"
    }
    print $a;               # 输出 "foo"
    print $b;               # 什么都不输出；$b已经超出了作用域</pre>
		<p>&#37197;合使用<code>my</code>&#21644;Perl脚本顶部的<code>use strict;</code>&#65292;意味着解释器将检查某些常见的编程 错误。举例来说，在上面的例子里，最后的<code>print $b</code>&#20250;产生一个编译时错误并阻止你 运行程序。强烈推荐使用<code>strict</code>&#12290;</p>
		<h2><span id="(26465)(20214)(21644)(24490)(29615)(32467)(26500)">&#26465;件和循环结构</span></h2>
		<p>Perl拥有几乎所有常见的条件和循环结构，除了case/switch(但假如你实在想要， Perl 5.8及以上的版本或CPAN里有一个Switch模块。关于模块和CPAN，请看后面关于模 块的章节)。</p>
		<p>&#26465;件可以是任何Perl表达式。参看下一节中关于比较和布尔逻辑操作符的列表。它们在 条件语句里很常用。</p>
		<dl>
			<dt><span id="if">if</span></dt>
			<dd>
				<pre>    if ( condition ) {
        ...
    } elsif ( other condition ) {
        ...
    } else {
        ...
    }</pre>
				<p>if还有一个否定版本：</p>
				<pre>    unless ( condition ) {
        ...
    }</pre>
				<p>&#36825;等同于<code>if (!<i>condition</i>)</code>&#65292;但是一个更易读的版本。</p>
				<p>&#27880;意在Perl里括号是必须的，就算块里只有一行。然而，有一个聪明的方法可以让你的 单行语句块看起来更像英语：</p>
				<pre>    # 传统方式
    if ($zippy) {
        print "Yow!";
    }

    # Perlish前置方式
    print "Yow!" if $zippy;
    print "We have no bananas" unless $bananas;</pre>
			</dd>
			<dt><span id="while">while</span></dt>
			<dd>
				<pre>    while ( condition ) {
        ...
    }</pre>
				<p>&#22522;于同样的原因，也有一个否定版本 -- <code>unless</code>&#65306;</p>
				<pre>    until ( condition ) {
        ...
    }</pre>
				<p>&#20320;也可以使用条件后置的<code>while</code>&#65306;</p>
				<pre>    print "LA LA LA\n" while 1;          # 永远循环</pre>
			</dd>
			<dt><span id="for">for</span></dt>
			<dd>
				<p>&#36319;C一模一样：</p>
				<pre>    for ($i=0; $i &lt;= $max; $i++) {
        ...
    }</pre>
				<p>&#22312;Perl里很少需要用到C样式的循环，因为Perl提供了更友善的列表遍历方法 -- <code>foreach</code>&#24490;环。</p>
			</dd>
			<dt><span id="foreach">foreach</span></dt>
			<dd>
				<pre>    foreach (@array) {
        print "This element is $_\n";
    }

    # 你不一定非得使用缺省的$_...
    foreach my $key (keys %hash) {
        print "The value of $key is $hash{$key}\n";
    }</pre>
			</dd>
		</dl>
		<p>&#20851;于循环结构(以及一些这篇概览里没有提到的结构)的更多细节，请参见<a href="perlsyn.html" class="podlinkpod">perlsyn</a>&#12290;</p>
		<h2><span id="(20869)(24314)(25805)(20316)(31526)(21644)(20989)(25968)">&#20869;建操作符和函数</span></h2>
		<p>Perl自带了一大套内建函数。有一些我们已经见识过了：<code>print</code>&#12289;<code>sort</code>&#21644; <code>reverse</code>&#12290;<a href="perlfunc.html" class="podlinkpod">perlfunc</a>&#30340;开始处有内建函数的完整列表。另外你可以很方便地使用 <code>perldoc -f <i>functionname</i></code>&#26597;看某个给定函数。</p>
		<p>Perl操作符详细记述于<a href="perlop.html" class="podlinkpod">perlop</a>&#12290;不过这里我们先看看一些最常用的：</p>
		<dl>
			<dt><span id="(31639)(26415)">&#31639;术</span></dt>
			<dd>
				<pre>    +   加
    -   减
    *   乘
    /   除</pre>
			</dd>
			<dt><span id="(25968)(23383)(27604)(36739)">&#25968;字比较</span></dt>
			<dd>
				<pre>    ==  相等
    !=  不等
    &lt;   小于
    &gt;   大于
    &lt;=  小等于
    &gt;=  大等于</pre>
			</dd>
			<dt><span id="(23383)(31526)(20018)(27604)(36739)">&#23383;符串比较</span></dt>
			<dd>
				<pre>    eq  相等
    ne  不等
    lt  小于
    gt  大于
    le  小等于
    ge  大等于</pre>
				<p>(为什么我们要分离数字和字符串比较？因为我们没有指定的变量类型，而perl需要知道 我们是要按数字排序(99应该小于100)，还是按字符排序(100应该在99前面)。</p>
			</dd>
			<dt><span id="(24067)(23572)(36923)(36753)">&#24067;尔逻辑</span></dt>
			<dd>
				<pre>    &amp;&amp;  and
    ||  or
    !   not</pre>
				<p>(<code>and</code>&#12289;<code>or</code>&#21644;<code>not</code>&#19981;仅仅是在上表中作为操作符的描述 -- 它们也是享有Perl支 持的操作符。它们比C样式的操作符更易读，但是与<code>&amp;&amp;</code>&#21450;其他友符具有不同的有限级。 查看<a href="perlop.html" class="podlinkpod">perlop</a>&#20197;获取更多细节。)</p>
			</dd>
			<dt><span id="(20854)(20182)">&#20854;他</span></dt>
			<dd>
				<pre>    =   赋值
    .   字符串比较
    x   字符串乘
    ..  范围操作符(创建数字的列表)</pre>
			</dd>
		</dl>
		<p>&#35768;多操作符可以和<code>=</code>&#32467;合使用，像下面这样：</p>
		<pre>    $a += 1;        # same as $a = $a + 1
    $a -= 1;        # same as $a = $a - 1
    $a .= "\n";     # same as $a = $a . "\n";</pre>
		<h2><span id="(25991)(20214)(21644)I/O">&#25991;件和I/O</span></h2>
		<p>&#20320;可以使用<code>open()</code>&#20989;数打开一个文件用于输入或输出。在<a href="perlfunc.html" class="podlinkpod">perlfunc</a>&#21644; <a href="perlopentut.html" class="podlinkpod">perlopentut</a>&#20013;有详细得近乎奢侈的文档。简而言之：</p>
		<pre>    open(INFILE,  "input.txt")   or die "Can't open input.txt: $!";
    open(OUTFILE, "&gt;output.txt") or die "Can't open output.txt: $!";
    open(LOGFILE, "&gt;&gt;my.log")    or die "Can't open logfile: $!";</pre>
		<p>&#20351;用<code>&lt;&gt;</code>&#25805;作符，你可以从一个已打开的文件句柄中读取数据。在标量上下文中， 它每次从文件句柄中读取一行。在列表上下文中，它会一次读入整个文件，并把每一行 赋给列表的一个元素：</p>
		<pre>    my $line  = &lt;INFILE&gt;;
    my @lines = &lt;INFILE&gt;;</pre>
		<p>&#19968;次读入整个文件也叫做啜食(sluping)。有时候会有用，不过很耗内存。多数的文本处理 工作可以使用Perl的循环结构一次一行地进行。</p>
		<p><code>&lt;&gt;</code>&#25805;作符最常见于<code>while</code>&#24490;环：</p>
		<pre>    while (&lt;INFILE&gt;) {     # 每行轮流赋给$_ 
        print "Just read in this line: $_";
    }</pre>
		<p>&#25105;们已经见过如何向标准输出打印 -- 使用<code>print()</code>&#12290;然而，<code>print()</code>&#36824;有一个可选 的第一个参数，用于指定输出用的文件句柄：</p>
		<pre>    print STDERR "This is your final warning.\n";
    print OUTFILE $record;
    print LOGFILE $logmessage;</pre>
		<p>&#24403;你进行完所有对文件句柄的操作后，你应该<code>close()</code>&#23427;们(虽然老实地说，如果你忘 了，Perl会替你清理)：</p>
		<pre>    close INFILE;</pre>
		<h2><span id="(27491)(21017)(34920)(36798)(24335)">&#27491;则表达式</span></h2>
		<p>Perl对正则表达式的支持是广泛而深入的。<a href="perlrequick.html" class="podlinkpod">perlrequick</a>&#12289;<a href="perlretut.html" class="podlinkpod">perlretut</a>&#21450;其他地方的 冗长文档都是关于这个主题的。尽管如此，简而言之：</p>
		<dl>
			<dt><span id="(31616)(21333)(21305)(37197)">&#31616;单匹配</span></dt>
			<dd>
				<pre>    if (/foo/)       { ... }  # 当$_包含"foo"时为真
    if ($a =~ /foo/) { ... }  # 当$a包含"foo"时为真</pre>
				<p>&#21305;配操作符<code>//</code>&#22312;<a href="perlop.html" class="podlinkpod">perlop</a>&#20013;有文档记述。它缺省对<code>$_</code>&#36827;行操作，或者可以通过使用 绑定操作符<code>=~</code>(也在<a href="perlop.html" class="podlinkpod">perlop</a>&#20013;有记述)绑定到其他变量。</p>
			</dd>
			<dt><span id="(31616)(21333)(26367)(25442)">&#31616;单替换</span></dt>
			<dd>
				<pre>    s/foo/bar/;               # 把$_中的foo替换成bar
    $a =~ s/foo/bar/;         # 把$a中的foo替换成bar
    $a =~ s/foo/bar/g;        # 把$a中的所有foo都替换成bar</pre>
				<p>&#26367;换操作符<code>s///</code>&#35760;述于<a href="perlop.html" class="podlinkpod">perlop</a>&#20013;。</p>
			</dd>
			<dt><span id="(26356)(22797)(26434)(30340)(27491)(21017)(34920)(36798)(24335)">&#26356;复杂的正则表达式</span></dt>
			<dd>
				<p>&#20320;不必仅仅匹配固定的字符串。实际上，通过使用复杂的正则表达式，你可以匹配梦想的 任何东西。这些都记述在超长的<a href="perlre.html" class="podlinkpod">perlre</a>&#25991;档里。但是趁这会儿，先看看快速作弊卡：</p>
				<pre>    .                   单个字符
    \s                  空白字符(空格、制表符(tab)、换行)
    \S                  非空白字符
    \d                  一个阿拉伯数字(0-9)
    \D                  一个非(阿拉伯)数字
    \w                  一个单词(word)字符(a-z、A-Z、0-9、_)
    \W                  一个非单词字符
    [aeiou]             匹配给定集合中的单个字符
    [^aeiou]            匹配给定集合之外的单个字符
    (foo|bar|baz)       匹配指定选择中的任何一个

    ^                   字符串开始
    $                   字符串结尾</pre>
				<p>&#38480;量符(quantifier)可以用来指定它前面的东西匹配的次数。这里"东西"指的可以是 一个文字的字符，或者上面列出的这些元字符中的一个，也可以是括在括号中的一组 字符和元字符。</p>
				<pre>    *                   0次或多次
    +                   1次或多次
    ?                   0次或1次
    {3}                 匹配3次
    {3,6}               匹配3到6次
    {3,}                匹配3次或更多</pre>
				<p>&#19968;些简要的例子：</p>
				<pre>    /^\d+/              以一个或多个阿拉伯数字开头的字符串
    /^$/                空字符串(开始位置和结束位置连在一起)
    /(\d\s){3}/         三个阿拉伯数字，每个数字后面有个空白字符(如："3 4 5 ") 
    /(a.)+/             匹配一个字符串，它的每个第奇数个字符都是a
                        (如："abacadaf") 

    # 下面这个循环从标准输入(STDIN)读入，然后输出每一个非空的行：
    while (&lt;&gt;) {
        print;
    }</pre>
			</dd>
			<dt><span id="(29992)(20110)(25429)(25417)(30340)(25324)(21495)">&#29992;于捕捉的括号</span></dt>
			<dd>
				<p>&#38500;了分组，括号还有第二个作用。它们可以被用来捕捉正则匹配的某些部分的结果以备 后用。结果被保存在<code>$1</code>&#12289;<code>$2</code>&#20381;此类推等变量里。</p>
				<pre>    # 一个简单而肮脏的方式来把email地址拆成几部分

    if ($email =~ /([^@]+)@(.+)/) {
        print "Username is $1\n";
        print "Hostname is $2\n";
    }</pre>
			</dd>
			<dt><span id="(20854)(20182)(27491)(21017)(34920)(36798)(24335)(29305)(24615)">&#20854;他正则表达式特性</span></dt>
			<dd><p>Perl正则还支持向后引用(backreference)、前瞻(lookahead)以及各种其他复杂的细节。 这些全都能从<a href="perlrequick.html" class="podlinkpod">perlrequick</a>&#12289;<a href="perlretut.html" class="podlinkpod">perlretut</a>&#21644;<a href="perlre.html" class="podlinkpod">perlre</a>&#20013;读到。</p></dd>
		</dl>
		<h2><span id="(32534)(20889)(23376)(20363)(31243)">&#32534;写子例程</span></h2>
		<p>&#32534;写子例程很容易：</p>
		<pre>    sub log {
        my $logmessage = shift;
        print LOGFILE $logmessage;
    }</pre>
		<p>&#37027;个<code>shift</code>&#26159;什么？好的，传递给子例程的参数都存储在一个叫<code>@_</code>&#30340;特殊数组里(参 阅<a href="perlvar.html" class="podlinkpod">perlvar</a>)。而<code>shift</code>&#20989;数的缺省参数正好是<code>@_</code>&#12290;因而 <code>my $logmessage = shift;</code>&#20250;移出参数列表的第一个元素并把它赋给<code>$logmessage</code>&#12290;</p>
		<p>&#25105;们也可以用其他方式来操作<code>@_</code>&#65306;</p>
		<pre>    my ($logmessage, $priority) = @_;       # 常用
    my $logmessage = $_[0];                 # 不常用，而且丑陋</pre>
		<p>&#23376;例程可以返回值：</p>
		<pre>    sub square {
        my $num = shift;
        my $result = $num * $num;
        return $result;
    }</pre>
		<p>&#20851;于编写子例程的更多信息，参见<a href="perlsub.html" class="podlinkpod">perlsub</a>&#12290;</p>
		<h2><span id="(38754)(21521)(23545)(35937)(OO)Perl">&#38754;向对象(OO)Perl</span></h2>
		<p>&#38754;向对象Perl相对简单，是用引用实现的。这些引用知道它们自己是哪种对象(基于Perl 中的包的概念)。然后，面向对象Perl严重超出了本文档的讨论范围。请阅读<a href="perlboot.html" class="podlinkpod">perlboot</a>&#12289; <a href="perltoot.html" class="podlinkpod">perltoot</a>&#12289;<a href="perltooc.html" class="podlinkpod">perltooc</a>&#21644;<a href="perlobj.html" class="podlinkpod">perlobj</a>&#12290;</p>
		<p>&#20316;为Perl初级程序员，你用到面向对象Perl最多是在使用第三方模块的时候，下面的文档 就会讲到。</p>
		<h2><span id="(20351)(29992)Perl(27169)(22359)">&#20351;用Perl模块</span></h2>
		<p>Perl模块提供一系列的特性以使你避免重复发明轮子。Perl模块可以从CPAN ( http:www.cpan.org/ )下载。大量的常用的模块被直接包含在Perl发行版里。</p>
		<p>&#27169;块类别从文本维护到网络协议到数据库集成，再到图形图像，应有尽有。模块的分类 列表也可以在CPAN上找到。</p>
		<p>&#35201;学习如何安装你从CPAN上下载的模块，阅读<a href="perlmodinstall.html" class="podlinkpod">perlmodinstall</a>&#12290;</p>
		<p>&#35201;学习如何使用一个特定的模块，使用<code>perldoc <i>Module::Name</i></code>&#12290;一般来说，你会需要 <code>use <i>Module::Name</i></code>&#12290;这会使你随后能够访问导出的函数或者该模块的一个面向对象 接口。</p>
		<p><a href="perlfaq.html" class="podlinkpod">perlfaq</a>&#37324;有关于各种常见任务的提问和答案，而且常常会建议你使用一些优秀CPAN模 块。</p>
		<p><a href="perlmod.html" class="podlinkpod">perlmod</a>&#25552;供Perl模块的全面概要。<a href="perlmodlib.html" class="podlinkpod">perlmodlib</a>&#21015;出了所有你安装的Perl自带的 模块。</p>
		<p>&#22914;果你有编写Perl模块的冲动，<a href="perlnewmod.html" class="podlinkpod">perlnewmod</a>&#20250;给你很好的建议。</p>
		<h1><span id="AUTHOR">AUTHOR</span></h1>
		<p>Kirrily "Skud" Robert &lt;skud@cpan.org&gt;</p>
		<p>Translated by Achilles Xu &lt;formalin14@gmail.com&gt;</p>
	</body>
</html>
