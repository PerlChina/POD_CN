
=encoding utf8

=for comment
Consistent formatting of this file is achieved with:
  perl ./Porting/podtidy pod/perlootut.pod

=head1 NAME

perlootut - Object-Oriented Programming in Perl Tutorial
perlootut - Perl教程之面向对象编程

=head1 DESCRIPTION

This document provides an introduction to object-oriented programming
in Perl. It begins with a brief overview of the concepts behind object
oriented design. Then it introduces several different OO systems from
L<CPAN|http://search.cpan.org> which build on top of what Perl
provides.

此文档提供了一个使用Perl进行面向对象编程的介绍。开篇是一个简短的关于面向
对象设计概念的概述，之后介绍了L<CPAN|http://search.cpan.org>上基于Perl的
各种OO系统。


By default, Perl's built-in OO system is very minimal, leaving you to
do most of the work. This minimalism made a lot of sense in 1994, but
in the years since Perl 5.0 we've seen a number of common patterns
emerge in Perl OO. Fortunately, Perl's flexibility has allowed a rich
ecosystem of Perl OO systems to flourish.

默认情况下，Perl内置的OO系统非常小巧，这使你必须自己做大部分工作。这种小
巧在1994年那个时代是合理的，但自Perl5.0发布以来，许多通用的模式在Perl OO
系统里面显现。幸运的是，Perl的灵活性允许Perl OO的生态系统演化和繁荣。

If you want to know how Perl OO works under the hood, the L<perlobj>
document explains the nitty gritty details.

如果你想知道Perl OO底层是如何工作的，L<perlobj>提供了详细的信息。

This document assumes that you already understand the basics of Perl
syntax, variable types, operators, and subroutine calls. If you don't
understand these concepts yet, please read L<perlintro> first. You
should also read the L<perlsyn>, L<perlop>, and L<perlsub> documents.

此文档假设你已经掌握了基本的Perl语法，变量类型，操作符和函数调用。如果你
还不理解这些概念，请先阅读L<perlintro>。同时你还应该阅读L<perlsyn>，
L<perlop>，L<perlsub>。

=head1 OBJECT-ORIENTED FUNDAMENTALS

=head1 面向对象基础

Most object systems share a number of common concepts. You've probably
heard terms like "class", "object, "method", and "attribute" before.
Understanding the concepts will make it much easier to read and write
object-oriented code. If you're already familiar with these terms, you
should still skim this section, since it explains each concept in terms
of Perl's OO implementation.

大部分面向对象编程系统都有一些通用的概念。你可能已经听说过了一些像“类”，
“对象”，“方法”和“属性”的术语。理解这些概念，使你能够更加容易的阅读和编写
面向对象代码。即使你已经熟悉了这些，你仍然可以阅读一下这一节，因为这里用
Perl的术语解释了这些概念。

Perl's OO system is class-based. Class-based OO is fairly common. It's
used by Java, C++, C#, Python, Ruby, and many other languages. There
are other object orientation paradigms as well. JavaScript is the most
popular language to use another paradigm. JavaScript's OO system is
prototype-based.

Perl的OO系统基于类(class-based)。基于类的OO是相当通用的，java，
C++，C#，Python，Ruby和很多其他语言都是如此。当然也有其他类型的面向对象
。Javascript就是使用另一种模式的流行语言，其OO系统是基于原型的
(prototype-based)。

=head2 Object

=head2 对象

An B<object> is a data structure that bundles together data and
subroutines which operate on that data. An object's data is called
B<attributes>, and its subroutines are called B<methods>. An object can
be thought of as a noun (a person, a web service, a computer).

B<对象>是聚合了数据和操作数据的函数的数据结构。对象的数据叫做B<属性>，它
的函数叫做B<方法>。一个对象可以想象成为一个名词(一个人，一个web服务，一
台计算机)。

An object represents a single discrete thing. For example, an object
might represent a file. The attributes for a file object might include
its path, content, and last modification time. If we created an object
to represent F</etc/hostname> on a machine named "foo.example.com",
that object's path would be "/etc/hostname", its content would be
"foo\n", and it's last modification time would be 1304974868 seconds
since the beginning of the epoch.

对象代表了一个单一但不连续的物体（????）。比如，它可能代表一个文件。文件
对象的属性可能包括路径，内容，最后修改时间。如果我们创建一个代表
F</etc/hostname>文件的对象，这个文件存放在名为"foo.example.com"的机器上
。这个对象的路径就应该是"/etc/hostname"，内容是"foo\n"，最后修改时间是自
epoch后1304974868秒。

The methods associated with a file might include C<rename()> and
C<write()>.

和文件相关的方法可以有C<rename()>和C<write()>。

In Perl most objects are hashes, but the OO systems we recommend keep
you from having to worry about this. In practice, it's best to consider
an object's internal data structure opaque.

Perl的大部分对象都是哈希，如果你使用我们推荐的OO系统，则你完全不必关心这
一点。实际上，最好将对象看做一个不透明的内部数据结构。

=head2 Class

=head2 类

A B<class> defines the behavior of a category of objects. A class is a
name for a category (like "File"), and a class also defines the
behavior of objects in that category.

B<类>定义了一个类别的对象的行为。类是一个类别的名字(比如"File")，类还
定义了这个类别中的对象的行为。

All objects belong to a specific class. For example, our
F</etc/hostname> object belongs to the C<File> class. When we want to
create a specific object, we start with its class, and B<construct> or
B<instantiate> an object. A specific object is often referred to as an
B<instance> of a class.

所有的对象都属于某个特定类。比如，我们的F</etc/hostname>对象属于C<File>
类。当我们想创建一个特定对象时，我们以它的类开始，B<创建>或者B<实例化>一
个对象。对象经常被称为一个类的B<实例>。

In Perl, any package can be a class. The difference between a package
which is a class and one which isn't is based on how the package is
used. Here's our "class declaration" for the C<File> class:

在Perl中，任何包都可以是一个类。一个包是否为类的区别在于这个包是如何被使
用的。以下是我们的C<File>类的"类定义"。

  package File;

In Perl, there is no special keyword for constructing an object.
However, most OO modules on CPAN use a method named C<new()> to
construct a new object:

对于Perl来说，没有一个特定的关键字来创建对象，但大部分CPAN上的OO模块都使
用一个名为C<new()>的方法。

  my $hostname = File->new(
      path          => '/etc/hostname',
      content       => "foo\n",
      last_mod_time => 1304974868,
  );

(Don't worry about that C<< -> >> operator, it will be explained
later.)

(别担心那个C<< -> >>操作符，接下来会解释)

=head3 Blessing


As we said earlier, most Perl objects are hashes, but an object can be
an instance of any Perl data type (scalar, array, etc.). Turning a
plain data structure into an object is done by B<blessing> that data
structure using Perl's C<bless> function.

如前所述，大多Perl的对象都是哈希，但它也可以是任意Perl数据类型(标量，数
组等)。把一个普通的Perl数据结构转换成对象的方式是使用C<bless>函数对它进
行B<Blessing>。

While we strongly suggest you don't build your objects from scratch,
you should know the term B<bless>. A B<blessed> data structure (aka "a
referent") is an object. We sometimes say that an object has been
"blessed into a class".

尽管我们强烈建议你不要从最底层开始创建你的对象，但你也应该知道B<bless>这
个术语。一个B<blessed>的数据结构是一个对象。我们有时候会说一个对象被“
blessed into a class”。

Once a referent has been blessed, the C<blessed> function from the
L<Scalar::Util> core module can tell us its class name. This subroutine
returns an object's class when passed an object, and false otherwise.

当一个变量被bless后，L<Scalar::Util>模块中的C<blessed>函数可以告诉我们它
的类名。当其参数为对象时，这个函数返回对象的类，否则返回false。

  use Scalar::Util 'blessed';

  print blessed($hash);      # undef
  print blessed($hostname);  # File

=head3 Constructor

=head3 构造器

A B<constructor> creates a new object. In Perl, a class's constructor
is just another method, unlike some other languages, which provide
syntax for constructors. Most Perl classes use C<new> as the name for
their constructor:

B<构造器>用来创建新对象。不像其他语言中提供了构造器语法一样，在Perl中，
一个类的构造器只是一个普通的方法。大部分Perl的类使用C<new>作为构造器的名
字。

  my $file = File->new(...);

=head2 Methods

=head2 方法

You already learned that a B<method> is a subroutine that operates on
an object. You can think of a method as the things that an object can
I<do>. If an object is a noun, then methods are its verbs (save, print,
open).

你已经知道了B<方法>就是操作对象的子程序。你也可以将方法看做对象能做的事
情。如果对象是名词，那么方法就是它的动作(保存，打印，打开)。

In Perl, methods are simply subroutines that live in a class's package.
Methods are always written to receive the object as their first
argument:

在Perl里面，方法是定义类的包里面的子程序。方法的第一个参数总是对象。

  sub print_info {
      my $self = shift;

      print "This file is at ", $self->path, "\n";
  }

  $file->print_info;
  # The file is at /etc/hostname

What makes a method special is I<how it's called>. The arrow operator
(C<< -> >>) tells Perl that we are calling a method.

方法的特殊之处在于它是“怎样被调用的”。箭头操作符C<< -> >>告诉Perl我们在
调用一个方法。

When we make a method call, Perl arranges for the method's B<invocant>
to be passed as the first argument. B<Invocant> is a fancy name for the
thing on the left side of the arrow. The invocant can either be a class
name or an object. We can also pass additional arguments to the method:

当我们调用方法时，Perl传递的第一个参数是方法的B<invocant>。B<Invocant>是
一个有意思的名字，它代表箭头左边的部分。Invocant可以是类名或者一个对象。
我们当然也可以给方法传递其他参数。

  sub print_info {
      my $self   = shift;
      my $prefix = shift // "This file is at ";

      print $prefix, ", ", $self->path, "\n";
  }

  $file->print_info("The file is located at ");
  # The file is located at /etc/hostname

=head2 Attributes

=head2 属性

Each class can define its B<attributes>. When we instantiate an object,
we assign values to those attributes. For example, every C<File> object
has a path. Attributes are sometimes called B<properties>.

所有的类都可以定义它的B<属性>。当我们初始化一个对象时，我们可以给属性赋
值。比如，每个C<文件>对象有一个路径。属性(attributes)有时也叫做
B<properties>

Perl has no special syntax for attributes. Under the hood, attributes
are often stored as keys in the object's underlying hash, but don't
worry about this.

Perl没有定义属性特殊的语法。在底层，属性就是类所对应哈希的键，不过你不需
要关注这点。

We recommend that you only access attributes via B<accessor> methods.
These are methods that can get or set the value of each attribute. We
saw this earlier in the C<print_info()> example, which calls C<<
$self->path >>.

我们推荐你只通过B<存取器>来访问属性。存取器是用来获得或设置属性的值的方
法。我们在C<print_info()>里面已经看到过了: C<< $self->path >>

You might also see the terms B<getter> and B<setter>. These are two
types of accessors. A getter gets the attribute's value, while a setter
sets it. Another term for a setter is B<mutator>

你可能也见过B<getter>和B<setter>这样的术语。这是两种不同的存取器。Getter
用来获得属性的值，而setter用来设置值。Setter的另一个叫法是B<mutator>

Attributes are typically defined as read-only or read-write. Read-only
attributes can only be set when the object is first created, while
read-write attributes can be altered at any time.

属性可以定义为只读或者可读写的。只读的属性只能在创建对象的时候被赋值，而
可读写的属性在任何时候都能够更改。

The value of an attribute may itself be another object. For example,
instead of returning its last mod time as a number, the C<File> class
could return a L<DateTime> object representing that value.

属性的值也可以是另外一个对象。比如，C<File>类可以返回一个L<DateTime>对象
代表其最后修改时间，而不是返回数字。

It's possible to have a class that does not expose any publicly
settable attributes. Not every class has attributes and methods.

类也可以没有任何公开的可设置的属性。不是每一个类都有属性和方法。

=head2 Polymorphism

=head2 多态

B<Polymorphism> is a fancy way of saying that objects from two
different classes share an API. For example, we could have C<File> and
C<WebPage> classes which both have a C<print_content()> method. This
method might produce different output for each class, but they share a
common interface.

B<多态>是描述来自不同类的对象公用一个接口的说法。比如，C<File>和
C<WebPage>类都可以有C<print_content()>方法。对于不同的类，调用这个方法的
输出可能不同，但它们有通用的接口。

While the two classes may differ in many ways, when it comes to the
C<print_content()> method, they are the same. This means that we can
try to call the C<print_content()> method on an object of either class,
and B<we don't have to know what class the object belongs to!>

尽管在很多方面，这两个类都不尽相同，但对于C<print_content>方法来说，他们
是一样的。这意味着我们可以在任一类的对象上调用这个C<print_content>方法，
而B<我们都不需要知道对象属于哪个类!>

Polymorphism is one of the key concepts of object-oriented design.

多态是面向对象设计的关键概念之一。

=head2 Inheritance

=head2 继承

B<Inheritance> lets you create a specialized version of an existing
class. Inheritance lets the new class to reuse the methods and
attributes of another class.

B<继承>可以让你创建已经存在的类的一个特殊版本。继承创建的新类能够复用原
来类的方法和属性。

For example, we could create an C<File::MP3> class which B<inherits>
from C<File>. An C<File::MP3> B<is-a> I<more specific> type of C<File>.
All mp3 files are files, but not all files are mp3 files.

比如，我们可以创建一个C<File::MP3>类，这个类从C<File>继承而来。
C<File::MP3>是C<File>的一个I<更加具体>的版本。所有的mp3都是文件，但不是
所有的文件都是mp3。


We often refer to inheritance relationships as B<parent-child> or
C<superclass/subclass> relationships. Sometimes we say that the child
has an B<is-a> relationship with its parent class.

我们经常把继承关系称为B<父-子>或者C<超类/子类>关系。有时候我们说子类是一
个父类（比如C<File::MP3>类是一个C<File>类）。

C<File> is a B<superclass> of C<File::MP3>, and C<File::MP3> is a
B<subclass> of C<File>.

C<File>是C<File::MP3>的超类，而C<File::MP3>是C<FILE>的子类。

  package File::MP3;

  use parent 'File';

The L<parent> module is one of several ways that Perl lets you define
inheritance relationships.

L<parent>模块是Perl让你定义继承关系的诸多方法之一。

Perl allows multiple inheritance, which means that a class can inherit
from multiple parents. While this is possible, we strongly recommend
against it. Generally, you can use B<roles> to do everything you can do
with multiple inheritance, but in a cleaner way.

Perl允许多重继承，这意味着一个类可以继承自多个父类。尽管这是可能的，但我
们强烈反对这样做。通常，你可以使用B<角色(roles)>来做到用多重继承能做到的
所有事情，而且做法还更加清晰。

Note that there's nothing wrong with defining multiple subclasses of a
given class. This is both common and safe. For example, we might define
C<File::MP3::FixedBitrate> and C<File::MP3::VariableBitrate> classes to
distinguish between different types of mp3 file.

注意对一个给定类，给它定义多个子类没有什么关系，这是通用且安全的做法。比
如，我们可以第一C<File::MP3::FixedBitrate>和
C<File::MP3::VariableBitrate>类，用来区分不同类别的mp3文件。

=head3 Overriding methods and method resolution

=head3 方法重载和方法解析

Inheritance allows two classes to share code. By default, every method
in the parent class is also available in the child. The child can
explicitly B<override> a parent's method to provide its own
implementation. For example, if we have an C<File::MP3> object, it has
the C<print_info()> method from C<File>:

继承允许两个类共享代码。默认情况下，父类的所有方法都能在子类中使用。子类
可以提供它自己的实现来B<重载>父类的方法。比如，如果我们有一个
C<File::MP3>对象，它有从C<File>而来的C<print_info()>方法。

  my $cage = File::MP3->new(
      path          => 'mp3s/My-Body-Is-a-Cage.mp3',
      content       => $mp3_data,
      last_mod_time => 1304974868,
      title         => 'My Body Is a Cage',
  );

  $cage->print_info;
  # The file is at mp3s/My-Body-Is-a-Cage.mp3

If we wanted to include the mp3's title in the greeting, we could
override the method:

如果我们希望能够打印mp3的名字，那么可以重载这个方法。

  package File::MP3;

  use parent 'File';

  sub print_info {
      my $self = shift;

      print "This file is at ", $self->path, "\n";
      print "Its title is ", $self->title, "\n";
  }

  $cage->print_info;
  # The file is at mp3s/My-Body-Is-a-Cage.mp3
  # Its title is My Body Is a Cage

The process of determining what method should be used is called
B<method resolution>. What Perl does is look at the object's class
first (C<File::MP3> in this case). If that class defines the method,
then that class's version of the method is called. If not, Perl looks
at each parent class in turn. For C<File::MP3>, its only parent is
C<File>. If C<File::MP3> does not define the method, but C<File> does,
then Perl calls the method in C<File>.

决定使用哪个方法的过程叫做B<方法解析>。Perl在这里所做的是：先查看对象的
所属类(这里是C<File::MP3>)，如果类定义了这个方法，那么调用这个类的版本。
否者，Perl查看每个父类。对于C<File::MP3>，它的父类只有C<File>。如果
C<File::MP3>没有定义这个方法，而C<File>定义了，那么Perl就会调用C<File>里
面的定义。

If C<File> inherited from C<DataSource>, which inherited from C<Thing>,
then Perl would keep looking "up the chain" if necessary.

如果C<File>继承自C<DataSource>，而C<DataSource>继承自C<Thing>，那么有必
要的话，Perl会“源着继承链自下而上”的查找方法定义。

It is possible to explicitly call a parent method from a child:

可以明确的在子类中调用父类的方法。

  package File::MP3;

  use parent 'File';

  sub print_info {
      my $self = shift;

      $self->SUPER::print_info();
      print "Its title is ", $self->title, "\n";
  }

The C<SUPER::> bit tells Perl to look for the C<print_info()> in the
C<File::MP3> class's inheritance chain. When it finds the parent class
that implements this method, the method is called.

C<SUPER::>部分告诉Perl，在C<File::MP3>继承链中查找C<print_info()>方法。
当在父类中找到了这个方法，则调用之。

We mentioned multiple inheritance earlier. The main problem with
multiple inheritance is that it greatly complicates method resolution.
See L<perlobj> for more details.

之前我们提到了多重继承。它的主要问题就是使方法解析变得非常复杂。更多细节
可以查阅L<perlobj>。

=head2 Encapsulation

=head2 封装

B<Encapsulation> is the idea that an object is opaque. When another
developer uses your class, they don't need to know I<how> it is
implemented, they just need to know I<what> it does.

B<封装>的理念是每个对象都是不透明的。当其他开发人员使用你的类时，他们
不需要知道这个类是I<如何>实现的，而只需要知道它做什么就可以了。

Encapsulation is important for several reasons. First, it allows you to
separate the public API from the private implementation. This means you
can change that implementation without breaking the API.

封装在许多方面都是非常重要的。首先，它允许你将公用接口和内部实现分开。这
意味着你能在修改实现的同时不破坏接口。

Second, when classes are well encapsulated, they become easier to
subclass. Ideally, a subclass uses the same APIs to access object data
that its parent class uses. In reality, subclassing sometimes involves
violating encapsulation, but a good API can minimize the need to do
this.

其次，如果很好的封装了类，继承也将变得更加简单。理想情况是，子类使用和父
类相同的接口来访问对象数据。实际上，有时候继承会破坏封装，但好的接口会减
少这种破坏。

We mentioned earlier that most Perl objects are implemented as hashes
under the hood. The principle of encapsulation tells us that we should
not rely on this. Instead, we should use accessor methods to access the
data in that hash. The object systems that we recommend below all
automate the generation of accessor methods. If you use one of them,
you should never have to access the object as a hash directly.

之前我们提到大部分Perl的对象都是用哈希实现的。封装的原则告诉我们不应依赖
于此，而应该使用存取器来获得哈希中的数据。我们接下来推荐的对象系统都能自
动生成存取器。如果你使用它们之中的任意一个，你永远不需要使用哈希来访问对
象。

=head2 Composition

=head2 组合

In object-oriented code, we often find that one object references
another object. This is called B<composition>, or a B<has-a>
relationship.

在面向对象的代码中，我们经常能看到一个对象指向另外一个对象，这叫做对象
B<组合>，或者B<有一个>关系。

Earlier, we mentioned that the C<File> class's C<last_mod_time>
accessor could return a L<DateTime> object. This is a perfect example
of composition. We could go even further, and make the C<path> and
C<content> accessors return objects as well. The C<File> class would
then be B<composed> of several other objects.

之前我们提到C<File>类的C<last_mod_time>方法能够返回一个C<DateTime>对象。
这就是一个对象组合的例子。我们也可以更进一步，让C<path>和C<content>存取
器也返回对象。那么C<File>就和许多其他的对象进行了组合。

=head2 Roles

=head2 角色B<Roles>

B<Roles> are something that a class I<does>, rather than something that
it I<is>. Roles are relatively new to Perl, but have become rather
popular. Roles are B<applied> to classes. Sometimes we say that classes
B<consume> roles.

B<角色>是一个类“做的事情”，而不是类是什么。对Perl来说，角色是一个相对较
新，同时也很流行的概念。角色B<应用>于类。有时我们说类B<消耗>角色。

Roles are an alternative to inheritance for providing polymorphism.
Let's assume we have two classes, C<Radio> and C<Computer>. Both of
these things have on/off switches. We want to model that in our class
definitions.

角色是继承之外，提供多态性的另一种选择。假设我们有两个类，C<Radio>和
C<Computer>。这两种物体都有开关键，我们想在类定义中为之建立模型。

We could have both classes inherit from a common parent, like
C<Machine>, but not all machines have on/off switches. We could create
a parent class called C<HasOnOffSwitch>, but that is very artificial.
Radios and computers are not specializations of this parent. This
parent is really a rather ridiculous creation.

我们可以让两个类都继承自同一父类，比如C<Machine>，但不是所有的机器都有开
关键。我们也可以建立一个叫C<HasOnOffSwitch>的父类，但这也太文绉绉了。
Radio和Computers不是这种父类的特殊体。这个父类定义得有点滑稽。

This is where roles come in. It makes a lot of sense to create a
C<HasOnOffSwitch> role and apply it to both classes. This role would
define a known API like providing C<turn_on()> and C<turn_off()>
methods.

这就是角色所适合的地方。此时建立一个C<HasOnOffSwitch>角色并将之应用于类
显得更加合理。这个角色可以定义如C<turn_on()>和C<turn_off()>之类的接口。

Perl does not have any built-in way to express roles. In the past,
people just bit the bullet and used multiple inheritance. Nowadays,
there are several good choices on CPAN for using roles.

Perl并没有关于角色的内置接口。过去，人们都只能别无选择的使用多重继承。而
现在，CPAN上有许多模块可以让你使用角色。

=head2 When to Use OO

=head2 什么时候使用OO

Object Orientation is not the best solution to every problem. In I<Perl
Best Practices> (copyright 2004, Published by O'Reilly Media, Inc.),
Damian Conway provides a list of criteria to use when deciding if OO is
the right fit for your problem:

面向对象并不是所有问题的最好解决方案。在I<Perl最佳实践>(copyright 2004,
Published by O'Reilly Media, Inc.)中，Damian Conway提供了一个决定OO是否
是解决你的问题的最好方案的列表。

=over 4

=item *

The system being designed is large, or is likely to become large.

在设计的系统非常庞大，或者可能变得庞大。

=item *

The data can be aggregated into obvious structures, especially if
there's a large amount of data in each aggregate.

数据可以聚合成一个明显的结构，特别是每个聚合中有大量数据的时候。

=item *

The various types of data aggregate form a natural hierarchy that
facilitates the use of inheritance and polymorphism.

各种类型的数据会形成自然的层次，让继承和多态的使用更为容易。

=item *

You have a piece of data on which many different operations are
applied.

你有一些数据，许多不同的运算都会应用在那些数据上面。

=item *

You need to perform the same general operations on related types of
data, but with slight variations depending on the specific type of data
the operations are applied to.

你必须对一些相关类型的数据做一些相同的通用运算，但是会根据运算所应用于特
定的数据类型而有些细微的差异。

=item *

It's likely you'll have to add new data types later.

你可能日后要增加新的数据类型。

=item *

The typical interactions between pieces of data are best represented by
operators.

数据之间的交互最好以运算符表示

=item *

The implementation of individual components of the system is likely to
change over time.

系统中个别组件的时间可能随时间而改变

=item *

The system design is already object-oriented.

系统设计已经是面向对象的

=item *

Large numbers of other programmers will be using your code modules.

有很多其他程序员会使用你的代码模块

=back

=head1 PERL OO SYSTEMS

=head1 PERL OO 系统

As we mentioned before, Perl's built-in OO system is very minimal, but
also quite flexible. Over the years, many people have developed systems
which build on top of Perl's built-in system to provide more features
and convenience.

就像前面所说的一样，Perl内置的OO系统非常小巧，也相当灵活。这些年来，在
Perl的内置系统上面，人们开发了许多高级系统，用以提供更多的特性和便利。

We strongly recommend that you use one of these systems. Even the most
minimal of them eliminates a lot of repetitive boilerplate. There's
really no good reason to write your classes from scratch in Perl.

我们强烈推荐你使用这些系统中的一个。它们之中即使是最轻巧的实现都能简化许
多重复工作。没有任何理由从零开始用Perl构建你的类。

If you are interested in the guts underlying these systems, check out
L<perlobj>.

如果你对这些系统的内部实现感兴趣，请参阅L<perlobj>

=head2 Moose

=head2 Moose

L<Moose> bills itself as a "postmodern object system for Perl 5". Don't
be scared, the "postmodern" label is a callback to Larry's description
of Perl as "the first postmodern computer language".

L<Moose>自称为“Perl 5的后现代对象系统”。不要被吓到，“后现代”一词出现
在这里，只是对Larry将Perl称作“第一种后现代计算机语言”的呼应。

C<Moose> provides a complete, modern OO system. Its biggest influence
is the Common Lisp Object System, but it also borrows ideas from
Smalltalk and several other languages. C<Moose> was created by Stevan
Little, and draws heavily from his work on the Perl 6 OO design.

C<Moose>提供了一个完全而现代化的OO系统。对它影响最大的是Common Lisp的面
向对象系统，同时它也借鉴了Smalltalk和许多其他编程语言的理念。C<Moose>由
Stevan Little创建，并从他对Perl 6 OO的设计工作中获益良多。

Here is our C<File> class using C<Moose>:

这是我们使用C<Moose>的C<File>类

  package File;
  use Moose;

  has path          => ( is => 'ro' );
  has content       => ( is => 'ro' );
  has last_mod_time => ( is => 'ro' );

  sub print_info {
      my $self = shift;

      print "This file is at ", $self->path, "\n";
  }

C<Moose> provides a number of features:

C<Moose>提供了许多特性：

=over 4

=item * Declarative sugar

=item * 声明式的语法糖

C<Moose> provides a layer of declarative "sugar" for defining classes.
That sugar is just a set of exported functions that make declaring how
your class works simpler and more palatable.  This lets you describe
I<what> your class is, rather than having to tell Perl I<how> to
implement your class.

C<Moose>提供了一层声明式的语法糖，用来定义类。这些语法糖只是一系列导出的
函数，它们可以使定义你的类的工作变得更加简单和更具可移植性。你可以描述你
的类是什么，而不用去告诉Perl怎样实现它。

The C<has()> subroutine declares an attribute, and C<Moose>
automatically creates accessors for these attributes. It also takes
care of creating a C<new()> method for you. This constructor knows
about the attributes you declared, so you can set them when creating a
new C<File>.

C<has()>子函数定义了一个属性，Moose会自动为其创建存取器。它还帮你创建了
C<new()>方法。这个构造器知道你所定义的属性，所以你能够在创建一个C<File>
对象时给它们赋值。

=item * Roles built-in

=item * 内置角色

C<Moose> lets you define roles the same way you define classes:

C<Moose>让你像定义类一样定义角色

  package HasOnOfSwitch;
  use Moose::Role;

  has is_on => (
      is  => 'rw',
      isa => 'Bool',
  );

  sub turn_on {
      my $self = shift;
      $self->is_on(1);
  }

  sub turn_off {
      my $self = shift;
      $self->is_on(0);
  }

=item * A miniature type system

=item * 一个小型的类型系统

In the example above, you can see that we passed C<< isa => 'Bool' >>
to C<has()> when creating our C<is_on> attribute. This tells C<Moose>
that this attribute must be a boolean value. If we try to set it to an
invalid value, our code will throw an error.

在上面的例子中，创建C<is_on>属性的时候，我们给C<has()>传递了参数C<< isa
=> 'Bool' >>。这是在告诉C<Moose>，这个属性必须是一个布尔值。如果我们给它
设置非法值，代码将会抛出错误。


=item * Full introspection and manipulation

=item * 完全的内省和控制机制

Perl's built-in introspection features are fairly minimal. C<Moose>
builds on top of them and creates a full introspection layer for your
classes. This lets you ask questions like "what methods does the File
class implement?" It also lets you modify your classes
programmatically.

Perl的内置内省特性及其微小。C<Moose>在它之上，为你的类建立了一个完全的内
省层，使得你可以问诸如“File类实现了哪些方法？”之类的问题。它还可以让你
按计划的修改你的类???。

=item * Self-hosted and extensible

=item * 自宿主(Self-hosted)和可扩展性

C<Moose> describes itself using its own introspection API. Besides
being a cool trick, this means that you can extend C<Moose> using
C<Moose> itself.

C<Moose>使用自己的内省API描述自己。除了这是一个很酷的技巧外，它还意味着
你可以用C<Moose>来扩展C<Moose>。

=item * Rich ecosystem

=item * 丰富的生态系统

There is a rich ecosystem of C<Moose> extensions on CPAN under the
L<MooseX|http://search.cpan.org/search?query=MooseX&mode=dist>
namespace. In addition, many modules on CPAN already use C<Moose>,
providing you with lots of examples to learn from.

在CPANS上的
L<MooseX|http://search.cpan.org/search?query=MooseX&mode=dist>命名空间
下，有一个关于Moose扩展的丰富的生态系统。此外，CPAN上很多模块已经在使用
C<Moose>，提供了许多可供学习的例子。

=item * Many more features

=item * 更多特性

C<Moose> is a very powerful tool, and we can't cover all of its
features here. We encourage you to learn more by reading the C<Moose>
documentation, starting with
L<Moose::Manual|http://search.cpan.org/perldoc?Moose::Manual>.

C<Moose>是一个非常强大的工具，我们不能在这里介绍它全部的特性。我们鼓励你
从L<Moose::Manual|http://search.cpan.org/perldoc?Moose::Manual>开始，通
过阅读C<Moose>的文档来学习它，

=back

Of course, C<Moose> isn't perfect.

当然，C<Moose>也不是完美的。

C<Moose> can make your code slower to load. C<Moose> itself is not
small, and it does a I<lot> of code generation when you define your
class. This code generation means that your runtime code is as fast as
it can be, but you pay for this when your modules are first loaded.

C<Moose>会使你的代码载入变慢。C<Moose>不是一个小型系统，当你定义你的类时
，它做了I<大量>代码生成工作。这意味着你的代码在运行期间能尽可能的快，但
在你的模块第一次被载入时，必须付出一些时间代价。

This load time hit can be a problem when startup speed is important,
such as with a command-line script or a "plain vanilla" CGI script that
must be loaded each time it is executed.

这个载入时间在启动速度重要的时候会成为一个问题。比如命令行脚本，或者必须
在每次执行都被载入的纯CGI脚本。

Before you panic, know that many people do use C<Moose> for
command-line tools and other startup-sensitive code. We encourage you
to try C<Moose> out first before worrying about startup speed.

不过先别慌，许多人的确在写命令行工具和其他对启动时间敏感的代码中使用了
C<Moose>。我们鼓励你先试用一下它，然后再考虑启动速度的问题。

C<Moose> also has several dependencies on other modules. Most of these
are small stand-alone modules, a number of which have been spun off
from C<Moose>. C<Moose> itself, and some of its dependencies, require a
compiler. If you need to install your software on a system without a
compiler, or if having I<any> dependencies is a problem, then C<Moose>
may not be right for you.

同时C<Moose>还有很多其他模块的依赖关系，其中大部分都是小型的独立模块，还
有一部分是为C<Moose>而写的。C<Moose>本身，以及它的一些依赖模块需要用到编
译器。如果你想将你的软件安装在一个没有编译器的系统上面，或者有I<任何>依
赖关系都是问题，那么C<Moose>可能不适合你。

=head3 Mouse

If you try C<Moose> and find that one of these issues is preventing you
from using C<Moose>, we encourage you to consider L<Mouse> next.
C<Mouse> implements a subset of C<Moose>'s functionality in a simpler
package. For all features that it does implement, the end-user API is
I<identical> to C<Moose>, meaning you can switch from C<Mouse> to
C<Moose> quite easily.

如果你使用了C<Moose>之后，发现这些问题之一阻止你继续使用它，我们建议你接
下来考虑一下C<Mouse>。C<Mouse>用一个更简单的包，实现了C<Moose>功能的一个
子集。对于它所实现的所有特性，其接口和C<Moose>是I<完全相同的>，这意味着
你可以非常容易的从C<Moose>迁移到C<Mouse>

C<Mouse> does not implement most of C<Moose>'s introspection API, so
it's often faster when loading your modules. Additionally, all of its
I<required> dependencies ship with the Perl core, and it can run
without a compiler. If you do have a compiler, C<Mouse> will use it to
compile some of its code for a speed boost.

C<Mouse>没有实现大部分C<Moose>的内省接口，所以在载入你的模块时，它的速度
更快。同时，它的所有依赖模块都由Perl核心提供，且不需要编译器就能运行。如
果你有编译器，那么C<Mouse>会用它来编译一些代码，从而加快运行速度。

Finally, it ships with a C<Mouse::Tiny> module that takes most of
C<Mouse>'s features and bundles them up in a single module file. You
can copy this module file into your application's library directory for
easy bundling.

最后，它还包含了一个C<Mouse::Tiny>模块，这个模块将大部分C<Mouse>特性打包
到了一个文件里面。把这个文件拷贝到你应用的库目录，你可以轻易打包你的应用
。

The C<Moose> authors hope that one day C<Mouse> can be made obsolete by
improving C<Moose> enough, but for now it provides a worthwhile
alternative to C<Moose>.

C<Moose>的作者希望通过充分改进C<Moose>，使C<Mouse>终有一天能够过时，但现
在C<Mouse>仍然提供了除C<Moose>之外的一个有价值的选择。

=head2 Class::Accessor

L<Class::Accessor> is the polar opposite of C<Moose>. It provides very
few features, nor is it self-hosting.

L<Class::Accessor>完全和C<Moose>相反。它提供了很少的特性，也不是自宿主的
。

It is, however, very simple, pure Perl, and it has no non-core
dependencies. It also provides a "Moose-like" API on demand for the
features it supports.

但它非常简单，完全由Perl实现，没有非核心依赖，同时还提供了“类Moose”的
借口。

Even though it doesn't do much, it is still preferable to writing your
own classes from scratch.

尽管做的不多，它仍然比你从头开始写你的类好。

Here's our C<File> class with C<Class::Accessor>:

这是用C<Class::Accessor>实现的C<File>类：

  package File;
  use Class::Accessor 'antlers';

  has path          => ( is => 'ro' );
  has content       => ( is => 'ro' );
  has last_mod_time => ( is => 'ro' );

  sub print_info {
      my $self = shift;

      print "This file is at ", $self->path, "\n";
  }


The C<antlers> import flag tells C<Class::Accessor> that you want to
define your attributes using C<Moose>-like syntax. The only parameter
that you can pass to C<has> is C<is>. We recommend that you use this
Moose-like syntax if you choose C<Class::Accessor> since it means you
will have a smoother upgrade path if you later decide to move to
C<Moose>.

C<antlers>导入符告诉C<Class::Accessor>我们想用类C<Moose>的语法来定义属性
。你唯一可以传给C<has>的参数是C<is>。当你使用C<Class::Accessor>时，我推
荐你使用类Moose的语法，这意味着当你将来决定使用C<Moose>时，你可以更平滑
的升级。

Like C<Moose>, C<Class::Accessor> generates accessor methods and a
constructor for your class.

像C<Moose>一样，C<Class::Accessor>为类自动创建构造器和存取器。

=head2 Object::Tiny


Finally, we have L<Object::Tiny>. This module truly lives up to its
name. It has an incredibly minimal API and absolutely no dependencies
(core or not). Still, we think it's a lot easier to use than writing
your own OO code from scratch.

最后介绍C<Object::Tiny>。这个模块就如它的名字，完全没有依赖关系且借口及
其简单。但我们仍然认为比起自己写你的OO代码，使用这个模块更加容易。

Here's our C<File> class once more:

再一次，这是我们的C<File>类：

  package File;
  use Object::Tiny qw( path content last_mod_time );

  sub print_info {
      my $self = shift;

      print "This file is at ", $self->path, "\n";
  }

That's it!

这就足够了!

With C<Object::Tiny>, all accessors are read-only. It generates a
constructor for you, as well as the accessors you define.

使用C<Object::Tiny>，所有的存取器都是只读的。它为你类生成构造器，也为你
定义的属性生成存取器。

=head2 Role::Tiny

As we mentioned before, roles provide an alternative to inheritance,
but Perl does not have any built-in role support. If you choose to use
Moose, it comes with a full-fledged role implementation. However, if
you use one of our other recommended OO modules, you can still use
roles with L<Role::Tiny>

我们前面提过，角色提供了继承之外的其他选择，但Perl没有内置的角色支持。如
果你选择使用Moose，它提供了一个成熟的角色实现。如果你使用其他我们推荐的
OO模块，你仍然可以通过L<Role::Tiny>使用角色。

C<Role::Tiny> provides some of the same features as Moose's role
system, but in a much smaller package. Most notably, it doesn't support
any sort of attribute declaration, so you have to do that by hand.
Still, it's useful, and works well with C<Class::Accessor> and
C<Object::Tiny>

C<Role::Tiny>提供了一些Moose角色系统的特性，但它更加小巧。值得注意的是，
它不支持任何属性定义，所以你必须手动定义它们。但它任然十分有用，并且和
C<Class::Accessor>或C<Object::Tiny>在一起工作得很好。

=head2 OO System Summary

=head2 OO系统总结

Here's a brief recap of the options we covered:

这是关于我们提到的模块的一个简单回顾

=over 4

=item * L<Moose>

C<Moose> is the maximal option. It has a lot of features, a big
ecosystem, and a thriving user base. We also covered L<Mouse> briefly.
C<Mouse> is C<Moose> lite, and a reasonable alternative when Moose
doesn't work for your application.

C<Moose>是最好的选择。它提供了许多特性，强大的生态系统，大量的用户基础。
我们也简单的提到了C<Mouse>，它是C<Moose>的简化版，也是当Moose不适合于你
的应用的时候的一个合理选择。

=item * L<Class::Accessor>

C<Class::Accessor> does a lot less than C<Moose>, and is a nice
alternative if you find C<Moose> overwhelming. It's been around a long
time and is well battle-tested. It also has a minimal C<Moose>
compatibility mode which makes moving from C<Class::Accessor> to
C<Moose> easy.

C<Class::Accessor>做得比C<Moose>少许多，如果你发现Moose太重量级了，它是
一个很好的选择。这个模块已经存在了相当长时间，而且也通过了很好的测试。它
还提供了一个轻量的C<Moose>兼容接口，这使得从C<Class::Accessor>迁移到
C<Moose>非常简单。

=item * L<Object::Tiny>

C<Object::Tiny> is the absolute minimal option. It has no dependencies,
and almost no syntax to learn. It's a good option for a super minimal
environment and for throwing something together quickly without having
to worry about details.

C<Object::Tiny>是最后的选择。它没有任何依赖，不需要学习任何语法。当你需
要一个超级简单的环境，并且不需要考虑细节的将一些东西捏合起来时，它是一个
不错的选择。

=item * L<Role::Tiny>

Use C<Role::Tiny> with C<Class::Accessor> or C<Object::Tiny> if you
find yourself considering multiple inheritance. If you go with
C<Moose>, it comes with its own role implementation.

如果你发现自己在考虑多重继承的时候，可以组合使用C<Role::Tiny>和
C<Class::Accessor>或C<Object::Tiny>。如果你使用C<Moose>，它提供了自己的
角色实现。

=back

=head2 Other OO Systems

=head2 其他OO系统

There are literally dozens of other OO-related modules on CPAN besides
those covered here, and you're likely to run accross one or more of them
if you work with other people's code.

除了这里提到的OO系统外，CPAN上还有成堆的相关模块。当你在使用别人的代码时
，很有可能就会碰到它们。

In addition, plenty of code in the wild does all of its OO "by hand",
using just the Perl built-in OO features. If you need to maintain such
code, you should read L<perlobj> to understand exactly how Perl's
built-in OO works.

其次，还有许多代码使用Perl的内置OO特性“手动”的实现它自己的OO。如果你需
要维护这种代码，你必须阅读L<perlobj>，理解Perl的内置OO是如何工作的。

=head1 CONCLUSION

=head1 总结

As we said before, Perl's minimal OO system has lead to a flourishing
of OO systems on CPAN. While you can still drop down to the bare metal
and write your classes by hand, there's really no reason to do that in
2011.

就像我们前面所说，Perl轻量的OO系统使得CPAN上面存在大量的OO模块。尽管你
仍然可以选择自己手动编写你的类，但在现在，2011，你没有任何理由要去那样做。

For small systems, L<Object::Tiny> and L<Class::Accessor> both provide
minimal object systems that take care of basic boilerplate for you.

对于小项目，L<Object::Tiny>和L<Class::Accessor>都提供了一个轻量的对象系
统，能够解决你的基本问题。

For bigger projects, L<Moose> provides a rich set of features that will
let you focus on implementing your business logic.

对于更大的项目，L<Moose>提供了丰富的特性，使你能够关注在业务逻辑层面上。

We encourage you to play with and evaluate L<Moose>,
L<Class::Accessor>, and L<Object::Tiny> to see which OO system is right
for you.

我们鼓励你使用并测试这些模块，L<Moose>，L<Class::Accessor>，
L<Object::Tiny>，然后再决定哪个适合于你。

=head1 TRANSLATORS

woosley. xu.<woosley.xu@gmail.com>

=cut
