=head1 NAME

perlunitut - Perl Unicode Tutorial

perlunitut - Perl万国码指南

=head1 DESCRIPTION

The days of just flinging strings around are over. It's well established that
modern programs need to be capable of communicating funny accented letters, and
things like euro symbols. This means that programmers need new habits. It's
easy to program Unicode capable software, but it does require discipline to do
it right.

编程语言只能处理简单字符的日子一去不复返了！现代程序必须能够和那些“滑稽
的”重音字母以及像欧洲符号一样的字符打交道。这意味着程序员要养成新的习惯
。编写能够处理Unicode的软件并不困难，但要把这件事情做好做对，的确需要一
些规范。


There's a lot to know about character sets, and text encodings. It's probably
best to spend a full day learning all this, but the basics can be learned in
minutes. 

要了解字符集和字符编码，需要知道的很多。最好你能花一天时间来学习这些，但
对于基础知识，几分钟时间就够了。

These are not the very basics, though. It is assumed that you already
know the difference between bytes and characters, and realise (and accept!)
that there are many different character sets and encodings, and that your
program has to be explicit about them. Recommended reading is "The Absolute
Minimum Every Software Developer Absolutely, Positively Must Know About Unicode
and Character Sets (No Excuses!)" by Joel Spolsky, at
L<http://joelonsoftware.com/articles/Unicode.html>.

这些知识也不算很“基础”。这里假设你已经懂得字节和字符之间的区别，知道有很
多不同的字符集和编码，并且你的程序要很明确的区分它们。推荐的阅读物为"The
Absolute Minimum Every Software Developer Absolutely, Positively Must
Know About Unicode and Character Sets (No Excuses!)" 作者 Joel Spolsky,
L<http://joelonsoftware.com/articles/Unicode.html>.

This tutorial speaks in rather absolute terms, and provides only a limited view
of the wealth of character string related features that Perl has to offer. For
most projects, this information will probably suffice.

这篇指南使用通用术语，简单的介绍了Perl提供的，与字符串相关的特性。对于大
多数项目，这些信息应该已经足够了。

=head2 Definitions

=head2 定义

It's important to set a few things straight first. This is the most important
part of this tutorial. This view may conflict with other information that you
may have found on the web, but that's mostly because many sources are wrong.

在开头将一些概念弄清楚非常重要。这也是本篇指南最重要的部分。这里的提供的
信息可能和你之前在网络上找到的相冲突，最可能的原因是：它们都错了。

You may have to re-read this entire section a few times...

你可能要重读这整节几次

=head3 Unicode

=head3 万国码(Unicode)

B<Unicode> is a character set with room for lots of characters. The ordinal
value of a character is called a B<code point>.   (But in practice, the
distinction between code point and character is blurred, so the terms often
are used interchangeably.)

B<Unicode>是一个字符集，它提供了容纳字符的空间。字符的序数值叫做B<码位(code
point)>。(实际上，码位和字符之间的区别已经很模糊了，这两个术语经常互用。)
    
There are many, many code points, but computers work with bytes, and a byte has
room for only 256 values.  Unicode has many more characters than that,
so you need a method to make these accessible.

这世界上有很多很多很多码位，但计算机用字节来工作，一个字节自只能提供256
个值。万国码中包含的字符比这多多了，所以你必须使用某种方法来获得这些字符
。

Unicode is encoded using several competing encodings, of which UTF-8 is the
most used. In a Unicode encoding, multiple subsequent bytes can be used to
store a single code point, or simply: character.

万国码可以使用许多种编码方式编码，其中UTF-8是用得最多的。在一种万国码编
码中，多字节的子序列可以用来存储一个码位，或者说：字符。

=head3 UTF-8

B<UTF-8> is a Unicode encoding. Many people think that Unicode and UTF-8 are
the same thing, but they're not. There are more Unicode encodings, but much of
the world has standardized on UTF-8. 

B<UTF-8>是一种万国码编码方式。很多人认为万国码和UTF-8是一个东西，实际上
不是。编码方式还有更多，但大半个世界都在以UTF-8为标准。

UTF-8 treats the first 128 codepoints, 0..127, the same as ASCII. They take
only one byte per character. All other characters are encoded as two or more
(up to six) bytes using a complex scheme. Fortunately, Perl handles this for
us, so we don't have to worry about this.

UTF-8的前128个码位和ASCII编码一样。每个字符代表使用一个字节。所有的其他
字符都使用一种复杂的方法编码成两个或者更多个（最高6）字节。幸运的是，
Perl替我们做了这工作，所以我们不必担心这一点。

=head3 Text strings (character strings)

=head3 文本串（字符串）

B<Text strings>, or B<character strings> are made of characters. Bytes are
irrelevant here, and so are encodings. Each character is just that: the
character.

B<Text strings>，或者B<character strings>有字符组成。这和字节没关系，和
编码也没关系。每个字符就是字符而已。

On a text string, you would do things like:

对于一个字符串，你可以做一些操作，比如：

    $text =~ s/foo/bar/;
    if ($string =~ /^\d+$/) { ... }
    $text = ucfirst $text;
    my $character_count = length $text;

The value of a character (C<ord>, C<chr>) is the corresponding Unicode code
point.

字符的值（C<ord>，C<chr>）是对应的万国码码位。

=head3 Binary strings (byte strings)

=head3 二进制串(字节串)

B<Binary strings>, or B<byte strings> are made of bytes. Here, you don't have
characters, just bytes. All communication with the outside world (anything
outside of your current Perl process) is done in binary.

B<二进制串(Binary strings)>或B<字节串(byte strings)>由字节组成。这里没有
字符，自有字节。所有与外界（任何你当前Perl进程之外的东西）的交流都是通过
二进制串来实现。

On a binary string, you would do things like:

在二进制串上，你可以做这些操作：

    my (@length_content) = unpack "(V/a)*", $binary;
    $binary =~ s/\x00\x0F/\xFF\xF0/;  # 胆子大的 :)
    print {$fh} $binary;
    my $byte_count = length $binary;

=head3 Encoding

=head3 编码

B<Encoding> (as a verb) is the conversion from I<text> to I<binary>. To encode,
you have to supply the target encoding, for example C<iso-8859-1> or C<UTF-8>.
Some encodings, like the C<iso-8859> ("latin") range, do not support the full
Unicode standard; characters that can't be represented are lost in the
conversion.

B<编码>（作动词）是从I<文本>到I<二进制>的转换。要给字符串编码，你必须给出目标编
码，比如C<iso-8859>或C<UTF-8>。有些编码并不完全支持万国码规范，比如
C<iso-8859>("latin")范围。在编码过程中，会丢失那些万国码不能代表的字符，

=head3 Decoding

=head3 解码

B<Decoding> is the conversion from I<binary> to I<text>. To decode, you have to
know what encoding was used during the encoding phase. And most of all, it must
be something decodable. It doesn't make much sense to decode a PNG image into a
text string.

B<解码>是从二进制到字符串的转换。解码时，你必须知道编码时用到的是那种编
码方式。最重要的是，二进制串必须能被解码。试图把一张PNG图片解码成字符串
是不现实的。

=head3 Internal format

=head3 内部格式

Perl has an B<internal format>, an encoding that it uses to encode text strings
so it can store them in memory. All text strings are in this internal format.
In fact, text strings are never in any other format!

Perl有它自己的B<内部格式>，它用这种内部格式来编码字符串，使其能保存到内
存里面。所有的字符串都是这种内部格式。事实上，它们从来没有其他格式。

You shouldn't worry about what this format is, because conversion is
automatically done when you decode or encode.

你不需要知道这是什么格式，因为在你解码或者编码的时候，其间的转换会自动进
行。

=head2 Your new toolkit

=head2 你的新工具包

Add to your standard heading the following line:

把下面几行加入到你的标准文件头部中：

    use Encode qw(encode decode);

Or, if you're lazy, just:

或则，如果你很懒，只需要：

    use Encode;

=head2 I/O flow (the actual 5 minute tutorial)

=head2 I/O流（真正的5分钟指南）

The typical input/output flow of a program is:

一个程序典型的输入/输出流如下：

    1. Receive and decode
    1. 收取，解码
    2. Process
    2. 处理
    3. Encode and output
    3. 编码，输出

If your input is binary, and is supposed to remain binary, you shouldn't decode
it to a text string, of course. But in all other cases, you should decode it.

如果你的输入是二进制，而且应该保持为二进制，那么你当然不需要把它解码为文
本串。但在其他所有情况下，你都应该将其解码。

Decoding can't happen reliably if you don't know how the data was encoded. If
you get to choose, it's a good idea to standardize on UTF-8.

如果你不知道数据是如何被编码的，解码也不会很可靠。你要选择的话，使用
UTF-8标准化是个好主意。

    my $foo   = decode('UTF-8', get 'http://example.com/');
    my $bar   = decode('ISO-8859-1', readline STDIN);
    my $xyzzy = decode('Windows-1251', $cgi->param('foo'));

Processing happens as you knew before. The only difference is that you're now
using characters instead of bytes. That's very useful if you use things like
C<substr>, or C<length>.

处理过程就像你以前所知一样。唯一的不同是，你在使用字符，而不是字节。当你
在使用如C<substr>或C<length>时，这一点非常有用。

It's important to realize that there are no bytes in a text string. Of course,
Perl has its internal encoding to store the string in memory, but ignore that.
If you have to do anything with the number of bytes, it's probably best to move
that part to step 3, just after you've encoded the string. Then you know
exactly how many bytes it will be in the destination string.

在文本串中没有字节，知道这一点很重要。当然，Perl有它的内部格式，用来在内
存中存储字符串，但请你忽略这一点。如果你需要做一些关于字节数目的事情，你
最好把这些事情挪到步骤3，将字符串编码之后。这样你才能准确的知道目标串里
面有多少字节。

The syntax for encoding text strings to binary strings is as simple as decoding:

将文本串编码成二进制串的方法如下：

    $body = encode('UTF-8', $body);

If you needed to know the length of the string in bytes, now's the perfect time
for that. Because C<$body> is now a byte string, C<length> will report the
number of bytes, instead of the number of characters. The number of
characters is no longer known, because characters only exist in text strings.

如果你需要知道字符串字节的长度，此时就是最好的时侯。因为C<$body>现在是字
节串了，C<length>会报告字节的数目，而不是字符的数目。字符数现在是未知的
，因为字符只存在于文本串。

    my $byte_count = length $body;

And if the protocol you're using supports a way of letting the recipient know
which character encoding you used, please help the receiving end by using that
feature! For example, E-mail and HTTP support MIME headers, so you can use the
C<Content-Type> header. They can also have C<Content-Length> to indicate the
number of I<bytes>, which is always a good idea to supply if the number is
known.

如果你所使用的协议支持设置你所使用的字符编码，那么请使用这个特性。比如
E-mail和HTTP支持MIME头部，这样你可以使用C<Content-Type>头部。它们还可以
有C<Content-Length>，用以表示I<字节>的数目。如果已经知道了这个数目，设置
它永远是个好注意。

    "Content-Type: text/plain; charset=UTF-8",
    "Content-Length: $byte_count"

=head1 SUMMARY

=head1 总结

Decode everything you receive, encode everything you send out. (If it's text
data.)

将你收到的所有东西解码，将你发出的所有东西编码。(如果是文本数据的话。)

=head1 Q and A (or FAQ)

After reading this document, you ought to read L<perlunifaq> too. 

阅读完这篇文档之后，你可以继续阅读L<perlunifaq>

=head1 ACKNOWLEDGEMENTS

=head1 致谢

Thanks to Johan Vromans from Squirrel Consultancy. His UTF-8 rants during the
Amsterdam Perl Mongers meetings got me interested and determined to find out
how to use character encodings in Perl in ways that don't break easily.

Thanks to Gerard Goossen from TTY. His presentation "UTF-8 in the wild" (Dutch
Perl Workshop 2006) inspired me to publish my thoughts and write this tutorial.

Thanks to the people who asked about this kind of stuff in several Perl IRC
channels, and have constantly reminded me that a simpler explanation was
needed.

Thanks to the people who reviewed this document for me, before it went public.
They are: Benjamin Smith, Jan-Pieter Cornet, Johan Vromans, Lukas Mai, Nathan
Gray.

=head1 AUTHOR

Juerd Waalboer <#####@juerd.nl>

=head1 SEE ALSO

L<perlunifaq>, L<perlunicode>, L<perluniintro>, L<Encode>

=head1 TRANSLATOR

Woosley Xu. C<woosley.xu@gmail.com>

